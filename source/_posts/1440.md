---
title: '[指南]使​​用32MB DVMT-prealloc的minStolenSize补丁的替代方法'
tags:
  - DVMT
categories:
  - MAC
date: 2017-08-05 14:12:31
---
### [指南]使​​用32MB DVMT-prealloc的minStolenSize补丁的替代方法
> Broadwell / Skylake / KabyLake的一个常见问题是PC OEM厂商的DVMT-prealloc设置相对较小。 苹果framebuffer kext通常假定为64mb或更大，大多数PC OEM只使用32mb。 而且由于BIOS有限，锁定BIOS等，通常没有办法轻易改变。

注意：有关更改DVMT-prealloc的更多信息，请参阅常见问题。
https://www.tonymacx86.com/threads/faq-read-first-laptop-frequent-questions.164990/ 

而且，即使可能，更改DVMT-prealloc的一些技术也可能是危险的，您可能不希望冒险。有minStolenSize补丁，可以禁用检查足够的DVMT-prealloc，但该补丁可能会导致不稳定，毛刺或其他奇怪的行为。 在帧缓冲区代码中断言有可能是很好的理由。幸运的是，可以将framebuffer修补到32mb DVMT-prealloc内。

#### 这是个Broadwell的例子
当然，修补一个替代的DVMT-prealloc的帧缓冲区比使用minStolenSize补丁有一点更多的参与，因为补丁特定于你使用的ig-platform-id。
我们来看看Broadwell，0x19260006上常用的ig-platform-id的帧缓冲区数据：

```
06002616 01030303 00002002 00005001
```
* 06002616只是0x19260006字节相反
* 01030303与端口和管道计数有关

接下来的两个32位项目是帧缓冲存储器大小和光标字节大小。
这两个项目的总和必须小于（或等于）DVMT-prealloc设置。

所以，0x02200000是34MB，0x01500000是21MB。 总和是55MB。 所以，显然它不会与一个32MB的DVMT-prealloc配合使用。

我们可以更改这些值，因此只需要32MB（实际上少一点）。 例如，我们知道在Haswell AppleIntelFramebufferAzul和ig-platform-id 0x0a260006只需要32MB。

`AppleIntelFramebufferAzul.kext`在0xa260006的标题中有这个：

```
0600260A 01030303 00000002 00003001 00006000
```
字节反转值，DVMT-prealloc要求为0x02000000（32MB），帧缓冲区大小为0x01300000（19MB），光标字节为0x00600000（6MB）。 当然我们通常会将6MB修补为9MB，否则会出现故障。

所以`Broadwell`的补丁`0x16260006`：

Comment：0x16260006，32MB BIOS，19MB帧缓冲区，9MB光标字节

* 名称：AppleIntelBDWGraphicsFramebuffer
* 查找：06002616 01030303 00002002 00005001
* 替换：06002616 01030303 00003001 00009000

上述补丁导致ig平台数据只需28MB。

您也可以缩短查找/替换数据，使其适用于更多的ig-platform-id值（有关更多信息，请参阅有关Skylake的讨论）。

#### 例如这个补丁：
Comment：0x16260006 / etc，32MB BIOS，19MB帧缓冲区，9MB光标字节（RehabMan）

* 名称：AppleIntelBDWGraphicsFramebuffer
* 查找：01030303 00002002 00005001
* 替换：01030303 00003001 00009000

...将适用于以下内容：0x19160002，0x16160002，0x16260002，0x16220002，0x162b0002，0x16260005，0x16260006。

详细信息，Skylake示例

我们来看看在Skylake，0x19160000中使用的另一个常见的ig-platform-id

注意：我只是在看这个10.12.4，10.11.6略有不同...类似于Broadwell（因为kext在framebuffer中有一个DVMT-prealloc规范）。

0x19160000的标题数据：

00001619 00000000 54880800 00000000 01030303 00002002 00005001

再次，与Broadwell的例子一样，我们也有34 + 21 = 55MB。 我们需要修剪，以适应32MB。

再次，我们可以使用已知的Goodwell数据：

评论：0x19160000 / etc，19MB帧缓冲区9MB游标字节（信用RehabMan）
名称：AppleIntelSKLGraphicsFramebuffer
查找：01030303 00002002 00005001
替换：01030303 00003001 00009000

请注意，Find / Replace不包括ig-platform-id本身（以及跟随它的其他字节）。 它不能使用，因为数据中的零实际上是占位符（fixup），当kext链接到内核缓存时，这将会改变。 但是使用从01030303（端口/管道计数数据）开始的数据是独一无二的。

补丁数据中无法指定ig-platform-id的结果是补丁应用于0x19160000以上。 例如，上面的补丁适用于ig-platform-id值0x191e0000,0x19160000,0x19260000,0x19270000,0x191b0000,0x193b0000,0x19120000。 其他ig-platform-id将需要与kext中找到的数据匹配的不同补丁数据。

激活补丁

就像使用minStolenSize补丁一样，Clover只能修补内核缓存中的kext。

所以激活程序保持不变：
- 确保在config.plist中输入正确的补丁
- 确保修补程序与您的ig-platform-id匹配
- 使用无效的ig-platform-id启动
- 重建缓存
- 启动与预期/有效的ig-platform-id

适用的ig-platform-id值 **
**
下面列出了可以修补的ig-platform-id值及其内存数据。

在AppleIntelBDWGraphicsFramebuffer中：
00000616 00030303 00000001 0000f000
00000e16 00030303 00000001 0000f000
00001616 00030303 00000001 0000f000
00001e16 00030303 00000001 0000f000
00002616 00030303 00000001 0000f000
00002b16 00030303 00000001 0000f000
00002216 00030303 00000001 0000f000
01000e16 01030303 00006002 00005001
01001e16 01030303 00006002 00005001
02000616 01030303 00002002 00005001
02001616 01030303 00002002 00005001
02002616 01030303 00002002 00005001
02002216 01030303 00002002 00005001
02002b16 01030303 00002002 00005001
03001216 01030403 00002002 00005001
04002b16 00030303 00002002 00005001
04002616 00030303 00002002 00005001
07002216 00030303 00006002 00006002
05002616 01030303 00002002 00005001
06002616 01030303 00002002 00005001
08002b16 00020202 00002002 00002002
08002616 00020202 00002002 00002002

并不是所有的ig-platform-id数据都可以这样修补。 有一些ig-platform数据使用fixup或动态调整的内存值，但目前仅在AppleIntelSKLGraphicsFramebuffer代码中（所有ig-platform-id值都可以在AppleIntelBDWGraphicsFramebuffer中打补丁）。

在AppleIntelSKLGraphicsFramebuffer中：
00001e19 ... 01030303 00002002 00005001
00001619 ... 01030303 00002002 00005001
00002619 ... 01030303 00002002 00005001
00002719 ... 01030303 00002002 00005001
00001b19 ... 01030303 00002002 00005001
00003b19 ... 01030303 00002002 00005001
00001219 ... 01030303 00002002 00005001
01000219 ... 00000000 00000000 00000000（不可打包）
01001719 ... 00000000 00000000 00000000（不可打包）
01001219 ... 00000000 00000000 00000000（not patchable）
01003219 ... 00000000 00000000 00000000（not patchable）
02001619 ... 01030303 00009003 00000000（可能不可打包）
02002619 ... 01030303 00009003 00000000（可能不可打包）
03001e19 ... 01030303 00008002 00000000（大概不可打包）
04002619 ... 01030303 00002002 00000000（可能不可打包）
04002719 ... 01030303 00009003 00000000（可能不可打包）
05003b19 ... 01030404 00002002 00000000（大概不可打包）
06001b19 ... 01010101 00006002 00000000（可能不可打包）
07002619 ... 01030303 00002002 00000000（可能不可打包）

结论

没有必要使用minStolenSize补丁或更改DVMT-prealloc ...相反，您可以修补framebuffer以匹配您的DVMT-prealloc的BIOS配置。

修改帧缓冲区以匹配您的DVMT-prealloc的BIOS设置可能比minStolenSize补丁和有限的BIOS选项更稳定，具有比更改DVMT-prealloc更少的风险。




