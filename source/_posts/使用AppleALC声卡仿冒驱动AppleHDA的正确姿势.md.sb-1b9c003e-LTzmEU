---
title: 使用AppleALC声卡仿冒驱动AppleHDA的正确姿势
date: 2017-11-09 09:23:23
urlname: Use-AppleALC-sound-card-to-drive-the-correct-posture-of-AppleHDA
tags:
- AppleALC
- AppleHDA
- 声卡仿冒
categories:
- 教程
---

# 大纲,写作中
# 前言
经常给网友仿冒声卡驱动, 一直都没有将过程写下来,鉴于每天会有许多人问如何仿冒声卡,就想将过程记录下来,供大家参考学习
# 提取codec
## 通过linux提取codec
### 制作Ubuntu Linux启动U盘:

* 下载Ubuntu Linux镜像,可以选择国内开源镜像站点下载:
[网易](http://mirrors.163.com/ubuntu-releases/) [搜狐](http://mirrors.sohu.com/ubuntu-releases/) [阿里云](https://mirrors.aliyun.com/ubuntu-releases/) 
    * 如果你只是想通过Linux提取codec的话,可以随便下载个旧的版本即可,比如这个[ubuntu 14.04.5LTS](https://mirrors.aliyun.com/ubuntu-releases/14.04/ubuntu-14.04.5-desktop-amd64.iso),如果想作为日后的生产力工具的话,我推荐你下载最新发布的[ubuntu 17.10](https://mirrors.aliyun.com/ubuntu-releases/17.10/ubuntu-17.10-desktop-amd64.iso)
* 制作Ubuntu Linux安装盘 
    * Windows下请使用工具`UltraISO`,方法略
    * macOS下制作过程:
        * 插入U盘,确定设备名,方法为打开磁盘工具,选择U盘,可以看到U盘下面有两个分区:`disk4s1`和`disk4s2`,那么U盘的设备名就是:`disk4`![diskutil_disk4](http://ous2s14vo.bkt.clouddn.com/diskutil_disk4.png)

        * 当然最简单的方法还是直接使用命令查看:`diskutil list`,输出的信息为:
        
        ```sh
 /dev/disk4 (internal, physical):
   #:                  TYPE NAME      SIZE IDENTIFIER
   0:     Apple_partition_scheme   *2.0 GB disk4
   1:        Apple_partition_map    4.1 KB disk4s1
   2:                  Apple_HFS    2.4 MB disk4s2
        ```
        这个`disk4`就是你要操作的设备名,后面我们会用到它
        
        * 卸载U盘,准备写入镜像,输入命令:
        `diskutil umountDisk disk4` # 卸载U盘
        * 使用`dd`命令将下载的Ubuntu Linux镜像恢复到U盘上,操作之前我有必要**提醒各位小白,万一你不小心输入错了设备名,那么你连哭的机会都没有,因为dd是按扇区直接物理写入磁盘,别到时候找不到数据了再悔不当初没有认真看到这段文字**
        
            ```sh
            sudo dd if=/Users/sky/Downloads/ISO/ubuntu-17.10-desktop-amd64.iso of=/dev/disk4 bs=1m
            ```
            命令输入完后,请仔细认真检查下,尤其是`of=/dev/disk4`这里,再三确认后回车执行,输入用户密码后请耐心等待6-7分钟,写盘速度取决于你的U盘,镜像恢复的过程中不会有任何的文字输出,U盘写入成功后会显示下面类似的输出信息:
        
            ```sh
~ % diskutil umountDisk disk4
Unmount of all volumes on disk4 was successful
~ % sudo dd if=/Users/sky/Downloads/ISO/ubuntu-17.10-desktop-amd64.iso of=/dev/disk4 bs=1m
Password:
1431+1 records in
1431+1 records out
1501102080 bytes transferred in 906.101477 secs (1656660 bytes/sec)
            ```
            *我的U盘竟然写了906秒(15分钟),我先找个地方哭会儿去*
            同时系统会弹出一个警告窗口,显示类似的信息:
            ![dd_error](http://ous2s14vo.bkt.clouddn.com/dd_error.png)

            那是因为Linux的分区格式是ext,在macOS系统下无法识别才会报错,但是其实一个支持UEFI引导的Ubuntu Linux 17.10启动U盘已经制作成功了.点击`Ignore`忽略或者`Eject`退出U盘
        * 现在您可以使用这个新制作的Ubuntu Linux安装U盘引导Linux去提取codec
## 提取codec
开机按引导设备快捷键`F12`或者`F8`进入引导设备选单,选择`Ubuntu Linux`所在的USB盘回车
![Boot_select](http://ous2s14vo.bkt.clouddn.com/Boot_select.jpg)
出现Ubuntu Linux的引导界面,选择`Try Ubuntu without installing`,该选项可以在不安装的情况下试用Ubuntu
![Ubuntu_boot](http://ous2s14vo.bkt.clouddn.com/Ubuntu_boot.jpg)
回车后稍候会进入Ubuntu桌面:
![ubuntu1](http://ous2s14vo.bkt.clouddn.com/ubuntu1.png)
按组合键`CTRL+ALT+t`打开终端,输入以下命令:

            ```sh
cd Desktop/ # 进入用户桌面
cp /proc/asound/card0/codec#0 . # 将codec#0复制到当时位置
sudo cp -R /sys/firmware/acpi/tables .  # 将acpi/tables目录复制到当时位置,tables目录包括了全部的DSDT和SSDT
ls -l   # 列表
sudo chown -R ubuntu:ubuntu *   # 将当前目录下所有文件及目录所有人修改为ubuntu
ls -l   # 列表
            ```
显示输出信息如下:
![ubuntu_codec_and_DSDT](http://ous2s14vo.bkt.clouddn.com/ubuntu_codec_and_DSDT.png)
将桌面上的codec#0和tables目录复制到LINUX以外的支持写入的盘符下,Linux下面的工作已经完成,您可以继续试用或者重启/关机.

# 整理有效节点
使用到的工具：`verbit.sh`,[下载链接](https://github.com/daliansky/dell7000/blob/master/hda-tools/verbit.sh)
用法: `verbit.sh codec#0`,它会生成如下显示的信息:

```ruby
Verbs from Linux Codec Dump File: codec#0

Codec: Realtek ALC3246   Address: 0   DevID: 283902550 (0x10ec0256)

   Jack   Color  Description                  Node     PinDefault             Original Verbs
--------------------------------------------------------------------------------------------------------
Digital Unknown  Mic at Int N/A              18 0x12   0x90a60170   01271c70 01271d01 01271ea6 01271f90
Unknown Unknown  Line Out at Ext N/A         19 0x13   0x40000000   01371c00 01371d00 01371e00 01371f40
 Analog Unknown  Speaker at Int N/A          20 0x14   0x90170140   01471c40 01471d01 01471e17 01471f90
    1/8   Black  Speaker at Ext Rear         24 0x18   0x411111f0   01871cf0 01871d11 01871e11 01871f41
    1/8   Black  Speaker at Ext Rear         25 0x19   0x411111f0   01971c10 01971d20 01971e81 01971f02
    1/8   Black  Speaker at Ext Rear         26 0x1a   0x411111f0   01a71cf0 01a71d11 01a71e11 01a71f41
 	1/8   Black  Speaker at Ext Rear     	 27 0x1b   0x411111f0   01b71cf0 01b71d11 01b71e11 01b71f41  
 Analog    Pink  Modem Hand at Ext N/A       29 0x1d   0x40779a2d   01d71c2d 01d71d9a 01d71e77 01d71f40
    1/8   Black  Speaker at Ext Rear         30 0x1e   0x411111f0   01e71cf0 01e71d11 01e71e11 01e71f41
    1/8   Black  HP Out at Ext Front         33 0x21   0x02211030   02171c30 02171d10 02171e21 02171f02
--------------------------------------------------------------------------------------------------------


   Jack   Color  Description                  Node     PinDefault             Modified Verbs
--------------------------------------------------------------------------------------------------------
Digital Unknown  Mic at Int N/A              18 0x12   0x90a60170   01271c70 01271d00 01271ea6 01271f90
Unknown Unknown  Line Out at Ext N/A         19 0x13   0x40000000   01371c00 01371d00 01371e00 01371f40
 Analog Unknown  Speaker at Int N/A          20 0x14   0x90170120   01471c20 01471d00 01471e17 01471f90
 Analog    Pink  Modem Hand at Ext N/A       29 0x1d   0x40779a2d   01d71c40 01d71d90 01d71e77 01d71f40
    1/8   Black  HP Out at Ext Front         33 0x21   0x02211030   02171c30 02171d10 02171e21 02171f01
--------------------------------------------------------------------------------------------------------

Modified Verbs in One Line: 01271c70 01271d00 01271ea6 01271f90 01371c00 01371d00 01371e00 01371f40 01471c20 01471d00 01471e17 01471f90 01d71c40 01d71d90 01d71e77 01d71f40 02171c30 02171d10 02171e21 02171f01
--------------------------------------------------------------------------------------------------------
```
如果你希望将输出结果保存下来,可以将命令改为:

```sh
verbit.sh codec#0 > ALC256_dump.txt
```
这个ALC256_dump.txt就是上面显示的输出信息,你可以使用其它的文字编辑器打开它.
重要的信息不能漏掉了,后面我们在编译声卡驱动的时候会经常用到它们:

```xml
Codec: Realtek ALC3246   Address: 0   DevID: 283902550 (0x10ec0256)
```
其中的:

| 名称 | 解释 |
|---|---|
|Codec: Realtek ALC3246|是告诉了你的声卡型号是ALC3246(ALC256)|
|Address: 0 | 会告诉你生成configdata的数据的前缀是0,比如上面显示输出信息最后一行的`Modified Verbs in One Line:`后面所有的数据中,每组数据的第一位就是这个 `0` ,如果`Address: 2`,那么每组数据的第一位就是 `2` ,这个后面我们会用到它 |
|DevID: 283902550 (0x10ec0256) | 283902550是0x10ec0256的10进制值,0x10ec 是指vendorID(芯片供应商ID),是REALTEK的设备标识,0256是指型号,去掉前面的0,您的声卡型号就是:ALC256|
    
    
过去的教程会告诉你,通过运行`verbit.sh`整理出来的节点是:

```xml
18 0x12 Mic at Int
20 0x14 Speaker at Int
33 0x21 HP Out at Ext Front
```
至于上面输出信息里显示的0x13 0x1d都是无效的节点.而且它只有三个有效的节点,我的声卡ALC256是用于笔记本,按理说它至少还应该存在另一个Mic Ext的节点,我需要找出它来.看来使用传统的方法已经无法满足我的求知欲了.
既然使用Linux可以提取codec,那么有没有可能 
# *通过Linux找出有效的节点*
呢?
为了测试我的声卡存在第四个节点,我需要找出耳机的Mic输入节点,于是乎重新引导进入Linux,插上耳机,它弹出了这个窗口:
![SelectAudioDevice](http://ous2s14vo.bkt.clouddn.com/SelectAudioDevice.png)
这三个选项的意思是让我选择声音设备,既然我希望找出耳机麦克风的输入,我就选择了中间带有耳麦的图标
进入`Sound Settings`,点击 `Input`,选择`Headset Microphone`,调节`Input volume`,对着耳麦说话,发现有输入电平了,再切换到内置麦克风`Internal Microphone`,也有输入电平,那么至少说明我的声卡功能是完整的,至少在Linux下它工作的很好.
![SoundInputDeviceSelect](http://ous2s14vo.bkt.clouddn.com/SoundInputDeviceSelect.png)
测试结果已经出来了,我想要知道耳麦的有效节点是什么,使用组合键`CTRL+ALT+t`打开终端,输入命令:`dmesg`看看它会有什么变化,结果我就看到了下面的文字:

```sh
[    5.040591] snd_hda_codec_realtek hdaudioC0D0: autoconfig for ALC3246: line_outs=1 (0x14/0x0/0x0/0x0/0x0) type:speaker
[    5.040593] snd_hda_codec_realtek hdaudioC0D0:    speaker_outs=0 (0x0/0x0/0x0/0x0/0x0)
[    5.040595] snd_hda_codec_realtek hdaudioC0D0:    hp_outs=1 (0x21/0x0/0x0/0x0/0x0)
[    5.040595] snd_hda_codec_realtek hdaudioC0D0:    mono: mono_out=0x0
[    5.040596] snd_hda_codec_realtek hdaudioC0D0:    inputs:
[    5.040598] snd_hda_codec_realtek hdaudioC0D0:      Headset Mic=0x19
[    5.040599] snd_hda_codec_realtek hdaudioC0D0:      Headphone Mic=0x1a
[    5.040600] snd_hda_codec_realtek hdaudioC0D0:      Internal Mic=0x12
```
我不想看到其它的输出信息,我只需要得到我想要的信息,于是将命令改为:

```bash
sky@sky-Inspiron-7560:~$ dmesg | grep snd_hda_codec_realtek
[    5.040591] snd_hda_codec_realtek hdaudioC0D0: autoconfig for ALC3246: line_outs=1 (0x14/0x0/0x0/0x0/0x0) type:speaker
[    5.040593] snd_hda_codec_realtek hdaudioC0D0:    speaker_outs=0 (0x0/0x0/0x0/0x0/0x0)
[    5.040595] snd_hda_codec_realtek hdaudioC0D0:    hp_outs=1 (0x21/0x0/0x0/0x0/0x0)
[    5.040595] snd_hda_codec_realtek hdaudioC0D0:    mono: mono_out=0x0
[    5.040596] snd_hda_codec_realtek hdaudioC0D0:    inputs:
[    5.040598] snd_hda_codec_realtek hdaudioC0D0:      Headset Mic=0x19
[    5.040599] snd_hda_codec_realtek hdaudioC0D0:      Headphone Mic=0x1a
[    5.040600] snd_hda_codec_realtek hdaudioC0D0:      Internal Mic=0x12
```
得到的输出结果跟上面的相同,于是我发现了在Linux下我的声卡的有效节点分别为:

* 0x14 Speaker out
* 0x21 HP out 
* 0x19 Headset Mic in
* 0x1a Headphone Mic in
* 0x12 Internal Mic in

暂且不讨论我的声卡是几节点,我发现通过linux完全可以得出声卡的有效节点,而且这种方式好像也不需要使用什么专用的工具,只是在linux下面通过内部命令`dmesg`无意中就被我发现了声卡中最挠头的找有效节点的打怪秘籍,这种方法在整个Hackintosh社区里还没见有人用过.看来这跟我之前使用linux经常会通过`dmesg`排错的使用习惯是分不开的,这里要由衷地给自己点一个大大的
# 赞

在这个特别的日子里`11.11`,没有陪女朋友的小伙伴们,都可以使用我刚get到的新技能愉快地打怪升级啦!

暂更于此,做个记号 2017年11月11日

-------
继续更新

先将节点整理成一个表格,这个表格里会包括之前整理出的数据

|有效节点|10进制|设备名称|
|---|---|---|
| 0x14 | 20 | Speaker out
| 0x21 | 21 | HP out 
| 0x19 | 25 | Headset Mic in
| 0x1a | 26 | Headphone Mic in
| 0x12 | 18 | Internal Mic in

之所以加上转换后的10进制,就是为了以后制作pathmap做准备

# 整理有效路径
使用codecgraph生成pathmap图
命令如下:

```sh
$ codecgraph codec\#0
Codec: Realtek ALC3246
Generating codec#0.svg
```
如果出现`error: dot executable not found (did you install graphviz?)`的错误提示的话,那么还需要执行下面的动作,打开终端,输入命令:

```sh
/usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)" # 安装brew
```
安装`brew`的过程中会提醒你安装`Xcode Command Tools`,请选择`yes`.
安装完`brew`之后,继续执行:

```sh
brew install graphviz   # 安装codecgraph所需要的依赖程序
```

这个生成的codec#0.svg就是声卡的pathmap,使用`Sketch.app`打开它
![codec](http://ous2s14vo.bkt.clouddn.com/codec.png)
是不是看了头老大?没错,我刚开始看的时候也是一头的雾水,看多了后就会总结出经验来
还记得我们在前面整理出的有效节点吧?!
还是以我的声卡为例,上文中我已经整理出5个节点,按照顺序来:
    0x14,这个是Speaker的节点,也就是喇叭,我们也俗称为外放,如果想让它正确地发声,就需要看看跟它连接的节点都有哪些,在图片里找到0x14位于图片的最下方,我把它放大下:
    ![node_output](http://ous2s14vo.bkt.clouddn.com/node_output.png)
通过观察我们会发现,0x14与0x02连接,转换成10进制就是20->2,同样的,0x21与0x03连接,转换成10进制就是33->3,我们把它放到表格中

|有效节点|10进制|设备名称|路径|
|---|---|---|---|
| 0x14 | 20 | Speaker out|**20->2**|
| 0x21 | 33 | HP out |**33->3**|
| 0x19 | 25 | Headset Mic in|
| 0x1a | 26 | Headphone Mic in|
| 0x12 | 18 | Internal Mic in|
怎么样?也没想像的那么复杂吧?两个输出设备的节点和路径已经整理出来,下一步,我们要把输入设备和节点整理出来
![node_input](http://ous2s14vo.bkt.clouddn.com/node_input.png)
再来看图片的上半部,最右侧的0x08和0x09是两个声音输入的节点,0x23和0x22是两个混音设备,最前方是设备节点,这个就是输入设备的路径.
我的声卡的0x12声音输入路径包括了3个节点;为了便于理解,被我圈起来的红线部分就是0x12(Mic in)的路径(pathmap),8->35->18就是路径,照样还是要将数据放到表格里
![node12_pathmap](http://ous2s14vo.bkt.clouddn.com/node12_pathmap.png)

|有效节点|10进制|设备名称|路径|
|---|---|---|---|
| 0x14 | 20 | Speaker out|**20->2**
| 0x21 | 33 | HP out |**33->3**|
| 0x19 | 25 | Headset Mic in||
| 0x1a | 26 | Headphone Mic in||
| 0x12 | 18 | Internal Mic in|**8->35->18**|
还记得文章前面通过linux找出来的有效节点不?我的耳麦可是支持输入的,节点也找出来了,是0x19(Headset Mic in),我需要将路径找出来,我发现0x19同时连接了两个节点:0x23和0x22,相应地路径为:8->35->25和9->34->25,顺手也把0x1a的路径也整理出来备用,将这两组数据补充进表格里

|有效节点|10进制|设备名称|路径|
|---|---|---|---|
| 0x14 | 20 | Speaker out|**20->2**
| 0x21 | 33 | HP out |**33->3**|
| 0x19 | 25 | Headset Mic in|**8->35->25** **9->34->25**|
| 0x1a | 26 | Headphone Mic in|**8->35->26** **9->34->26**|
| 0x12 | 18 | Internal Mic in|**8->35->18**|

至于0x1a是否有效暂且放到一边,一个包括了有效节点/设备名称/路径的表格就整理完成了,这里***需要强调的一点是:路径数值使用10进制***


# 整理ConfigData
> `ConfigData`的获得有两种方法:这两种方法分别为:通过`codec`里面的`Pin Default`提取以及通过`PinConfigs`提取,然后修正`ConfigData`.下面我们将分别介绍这两种提取方法
 

## 通过PinConfigs提取ConfigData
ConfigData数据位于`PinConfigs.kext/Contents/Info.plist`里,`PinConfigs.kext`作为`AppleALC`插件被加载.
用到的工具:`Plist Editor Pro.app`
还是以我的ALC256为例:打开`Info.plist`后,使用组合快捷键`⌘+f`打开搜索: `ALC256` 或者 `283902550` ,它会直接定位到你需要查找的数据位置,再按`⌘+g`,将相同的字符串全部搜索完毕,直到它又跳转到第一个搜索结果的位置,结果如下图:
![PlistEditorPro](http://ous2s14vo.bkt.clouddn.com/PlistEditorPro.png)
ALC256的ConfigData的数据有三组,分别对应的LayoutID为:13 28 56
将这三组ConfigData复制出来:

id:13 
`
01271C10 01271D00 01271EA6 01271F90 01471C20 01471D00 01471E17 01471F90 01971C30 01971D10 01971E8B 01971F02 02171C50 02171D10 02171E2B 02171F02 01470c02 
`

id:28 
`
01471C50 01471D00 01471E17 01471F90 01470c02 01A71C30 01A71D00 01A71EA0 01A71F90 02171C20 02171D10 02171E21 02171F00 
`

id:56 
`
01271C10 01271D00 01271EA6 01271F90 01471C20 01471D00 01471E17 01471F90 01971C30 01971D10 01971E8B 01971F02 01A71C40 01A71D10 01A71E81 01A71F02 01D71CF0 01D71D11 01D71E11 01D71F41 02171C50 02171D10 02171E2B 02171F02 01470c02 02170c02 `

这么看起来是杂乱无章的,我们将它格式化一下,每个节点一行,四组数据:
id:13 

```sh
01271C10 01271D00 01271EA6 01271F90 
01471C20 01471D00 01471E17 01471F90 
01971C30 01971D10 01971E8B 01971F02 
02171C50 02171D10 02171E2B 02171F02 01470c02 
```
id:28 

```sh
01471C50 01471D00 01471E17 01471F90 01470c02 
01A71C30 01A71D00 01A71EA0 01A71F90 
02171C20 02171D10 02171E21 02171F00 
```

id:56 

```sh
01271C10 01271D00 01271EA6 01271F90 
01471C20 01471D00 01471E17 01471F90 01470c02 
01971C30 01971D10 01971E8B 01971F02 
01A71C40 01A71D10 01A71E81 01A71F02 
01D71CF0 01D71D11 01D71E11 01D71F41 
02171C50 02171D10 02171E2B 02171F02 02170c02 
```
从中我们可以发现:
id:13为四行四节点,节点为:`0x12 0x14 0x19 0x21`
id:28为三行三节点,节点为:`0x14 0x1A 0x21`
id:56为六行六节点,节点为:`0x12 0x14 0x19 0x1A 0x1D 0x21`
现在有个问题摆在你们的面前,我上面明明刚说过每个节点为四组数据,那为什么在0x14和0x21的节点后面又多出来一组数据呢?这组数据又有什么作用呢?原来秘密都藏在`codec`里面,它定义了某些输出设备具有`EAPD`,比如0x14节点的数据:

```ruby
Node 0x14 [Pin Complex] wcaps 0x40058d: Stereo Amp-Out
  Control: name="Speaker Playback Switch", index=0, device=0
    ControlAmp: chs=3, dir=Out, idx=0, ofs=0
  Amp-Out caps: ofs=0x00, nsteps=0x00, stepsize=0x00, mute=1
  Amp-Out vals:  [0x00 0x00]
  Pincap 0x00010014: OUT EAPD Detect
  EAPD 0x2: EAPD
  Pin Default 0x90170120: [Fixed] Speaker at Int N/A
    Conn = Analog, Color = Unknown
    DefAssociation = 0x2, Sequence = 0x0
    Misc = NO_PRESENCE
  Pin-ctls: 0x40: OUT
  Unsolicited: tag=00, enabled=0
  Power states:  D0 D1 D2 D3 EPSS
  Power: setting=D0, actual=D0
  Connection: 1
     0x02
```
具有`EAPD`的节点需要添加参数`SET_EAPD_BTLENABLE`,转换成数值为`0x70c`,完整的数值为:`Address`+`节点`+`70c`+`02`,即:`01470c02`,它通过`hda-verb`可以执行,比如`CodecCommander`就是调用的`hda-verb`执行的命令.更多的`hda-verb`参数请参考我之前的文章:[hda-verb参数详表](https://blog.daliansky.net/hda-verb-parameter-detail-table.html)
这里我教大家一个简单判断`EAPD`节点的方法:那就是它通常会位于`Speaker Out`和`HP Out`这两个输出节点上.至于其它教程提到过的**关于`01470c02`是组神奇的代码,可以让外放发声**的说法是错误的,它可能刚好声卡的`Speaker Out`的输出节点是`0x14`而已.如果您的`Speaker Out`输出节点是`0x16`,那么就需要把它修改为`01670c02`,当然要遵守这个公式:`Address`+`节点`+`71c`+`02`

本节教程先更新到这里 11-13-2017 10:25PM

续更

另外一种找出`EAPD`节点的方法:使用工具`node_dump.sh`,它会显示出每个节点的信息,包括`EAPD`输出,详细的用法以后再补充上.

说了半天,也只说了一个`01470c02`是干什么用的,其它的四组数据都分别代表什么呢?这个话题如果展开讲的话,没个一两天是说不明白的.
接下来的部分就会介绍到这四组数据是怎么整理出来的.

## 通过`codec`里面的`Pin Default`提取并整理
将使用`verbit.sh`整理出来的`ALC256_dump.txt`重新打开:

```ruby
Verbs from Linux Codec Dump File: codec#0

Codec: Realtek ALC3246   Address: 0   DevID: 283902550 (0x10ec0256)

   Jack   Color  Description                  Node     PinDefault             Original Verbs
--------------------------------------------------------------------------------------------------------
Digital Unknown  Mic at Int N/A              18 0x12   0x90a60170   01271c70 01271d01 01271ea6 01271f90
Unknown Unknown  Line Out at Ext N/A         19 0x13   0x40000000   01371c00 01371d00 01371e00 01371f40
 Analog Unknown  Speaker at Int N/A          20 0x14   0x90170140   01471c40 01471d01 01471e17 01471f90
    1/8   Black  Speaker at Ext Rear         24 0x18   0x411111f0   01871cf0 01871d11 01871e11 01871f41
    1/8   Black  Speaker at Ext Rear         25 0x19   0x411111f0   01971c10 01971d20 01971e81 01971f02
    1/8   Black  Speaker at Ext Rear         26 0x1a   0x411111f0   01a71cf0 01a71d11 01a71e11 01a71f41
 	1/8   Black  Speaker at Ext Rear     	 27 0x1b   0x411111f0   01b71cf0 01b71d11 01b71e11 01b71f41  
 Analog    Pink  Modem Hand at Ext N/A       29 0x1d   0x40779a2d   01d71c2d 01d71d9a 01d71e77 01d71f40
    1/8   Black  Speaker at Ext Rear         30 0x1e   0x411111f0   01e71cf0 01e71d11 01e71e11 01e71f41
    1/8   Black  HP Out at Ext Front         33 0x21   0x02211030   02171c30 02171d10 02171e21 02171f02
--------------------------------------------------------------------------------------------------------
```
将数据整理成如下的样式:

* [Fixed]是内部设备
* [Jack]是通过插孔进行连接的外部设备
* [N/A]是其它未知设备

```ruby
Node	PinDefault		Description 
----------------------------------------------------------
0x12	0x90a60170		[Fixed]	Mic at Int       
0x13	0x40000000		[N/A]	Line Out at Ext N/A  
0x14	0x90170140		[Fixed]	Speaker at Int   
0x18	0x411111f0		[N/A]	Speaker at Ext Rear  
0x19	0x411111f0		[N/A]	Speaker at Ext Rear  
0x1a	0x411111f0		[N/A]	Speaker at Ext Rear  
0x1b	0x411111f0		[N/A]	Speaker at Ext Rear  
0x1d	0x40779a2d		[N/A]	Modem Hand at Ext N/A
0x1e	0x411111f0		[N/A]	Speaker at Ext Rear  
0x21	0x02211030		[Jack]	HP Out at Ext Front  
----------------------------------------------------------
```
将`PinDefault`进行小端转换[little-endian](https://zh.wikipedia.org/zh-hans/字节序),这里借用一张紫米教程里面的图片进行小端转换的理解:
![little-endian](http://ous2s14vo.bkt.clouddn.com/little-endian.jpg)
就是把`PinDefault`的数据两两对调,比如:`0x12`节点的`[Fixed]	Mic at Int`原始数据为:`0x90a60170`,去掉前面的`0x`,变成`90 a6 01 70`,
最前面的`90`跑到了最后,最后的`70`又跑到了最前面,中间的`a6`和`01`再对调下,就变成了`70 01 a6 90`.整理后,变成如下的格式:

```ruby
Node            c  d  e  f              Description
12		70 01 a6 90		[Fixed]	Mic at Int       
13		00 00 00 40		[N/A]	Line Out at Ext N/A  
14		40 01 17 90		[Fixed]	Speaker at Int   
18		f0 11 11 41		[N/A]	Speaker at Ext Rear  
19		f0 11 11 41		[N/A]	Speaker at Ext Rear  
1a		f0 11 11 41		[N/A]	Speaker at Ext Rear  
1b		f0 11 11 41		[N/A]	Speaker at Ext Rear  
1d		2d 9a 77 40		[N/A]	Modem Hand at Ext N/A
1e		f0 11 11 41		[N/A]	Speaker at Ext Rear  
21		30 10 21 02		[Jack]	HP Out at Ext Front  
```
下一步,我们要对数据进行修正,让它看起来更像`APPLE`.

## 修正`PinDefault`,并生成`ConfigData`
上一节我们只是把数据进一步地整理出来,并进行了格式化,我们并没有对数据进行修正.本节我们就开始进行`PinDefault`的修正,先上一张我整理出来的表格:
![pinconfigs](http://ous2s14vo.bkt.clouddn.com/pinconfigs.png)

* 前面我提到过通过Linux找到的节点`0x19`,它在Linux下面显示的设备为`Headset Mic`,在上一节中我们整理出的`0x19`的设备为:`[N/A]	Speaker at Ext Rear` , `PinDefault`值为:`f0 11 11 41`,通过上表我们得知,这个端口是被屏蔽掉的,就是不起作用的节点.
* 现在我们希望它能正常工作,我的想法是把它修正为:`[Jack] Mic at Ext`,一个可以正常工作的外部麦克输入设备,结合上面的表格,我将`f0 11 11 41`修改为:`70 20 a1 02`.
* 由于我的耳机插孔只有一个,也就是俗称的二合一插孔,我希望在上面的外麦克工作不正常的情况下,可以将耳麦和耳机输出定义成组合插孔(2in1),上表中`Connection Type`的连接类型中,正好有个`B=Combination`,它的意思就是:`组合`,我需要同时修正耳麦和耳机的数值:
    * `Mic at Ext` : `f0 11 11 41`->`70 20 ab 02`
    * `HP Out Ext` : `30 10 21 02`->`30 10 2b 02`

更新于:11-15-2017 16:41

继续更新
`0x1d`的节点为无效节点,所以必须把它屏蔽起来,为了让它更符合`APPLE`的规范,我们使用`f0 00 00 40`来屏蔽,包括其它的不用的节点.修正后的数据为:

```ruby
Node            c  d  e  f              Description
12		70 01 a6 90		[Fixed]	Mic at Int       
13		f0 00 00 40		[N/A]	Line Out at Ext N/A  
14		40 01 17 90		[Fixed]	Speaker at Int   
18		f0 00 00 40		[N/A]	Speaker at Ext Rear  
19		70 10 ab 02		[Jack]	Mic at Ext  
1a		f0 00 00 40		[N/A]	Speaker at Ext Rear  
1b		f0 00 00 40		[N/A]	Speaker at Ext Rear  
1d		f0 00 00 40		[N/A]	Modem Hand at Ext N/A
1e		f0 00 00 40		[N/A]	Speaker at Ext Rear  
21		30 10 2b 02		[Jack]	HP Out at Ext Front
```
现在, 我们可以生成最终的`ConfigData`了,
`ConfigData`的计算公式为:

```sh
Final Config:
Address + Node + 71c +【c】
Address + Node + 71d +【d】
Address + Node + 71e +【e】
Address + Node + 71f +【f】
```
这里的`c` `d` `e` `f`就是上面整理出来的2位数值
我的ALC256的`Address`值为0,现在我将节点`0x12`的`ConfigData`值通过上面的公式整理后得出:

```xml
01271c70 01271d01 01271ea6 01271f90
```
相应地,其它的节点整理出来的数据如下:

```xml
01271c70 01271d01 01271ea6 01271f90
01371cf0 01371d00 01371e00 01371f40
01471c40 01471d01 01471e17 01471f90 01470c02
01871cf0 01871d00 01871e00 01871f40
01971c70 01971d10 01971eab 01971f02
01a71cf0 01a71d00 01a71e00 01a71f40
01b71cf0 01b71d00 01b71e00 01b71f40
01d71cf0 01d71d00 01d71e00 01d71f40
01e71cf0 01e71d00 01e71e00 01e71f40
02171c30 02171d10 02171e2b 02171f02 02170c02
```

我将编辑的过程做了段视频,方便大家理解.

<video width="640" height="480" controls>
<source src="http://ous2s14vo.bkt.clouddn.com/ConfigData.mp4">
</video>

打开`Sublime Text.app`,按住鼠标中键打开块复制,将`c` `d` `e` `f`下面的数据块拷贝一份到最下面空白处,在第一列按鼠标中键一下拉到下面,输入`Address`值`0`,再把上方的`Node`下面的数据做块复制,粘贴到0后面,再输入:`71c`,再将`01271`做块复制到后面,再分别输入`d` `e` `f`即可.最后在`0x14`和`0x21`节点后面添加两组`EAPD`数据.
将上面整理出来的数据去掉每行的硬回车后得到的一组数据就是最终的`ConfigData`

`
01271c70 01271d01 01271ea6 01271f90 01371cf0 01371d00 01371e00 01371f40 01471c40 01471d01 01471e17 01471f90 01470c02 01871cf0 01871d00 01871e00 01871f40 01971c70 01971d10 01971eab 01971f02 01a71cf0 01a71d00 01a71e00 01a71f40 01b71cf0 01b71d00 01b71e00 01b71f40 01d71cf0 01d71d00 01d71e00 01d71f40 01e71cf0 01e71d00 01e71e00 01e71f40 02171c30 02171d10 02171e2b 02171f02 02170c02
`
到这里,`ConfigData`的数据就算整理完了.

# 找出适合你的id
这一节里,我们就来一起动手找出最适合你的注入id
正确的注入id可以保证您的声卡各项功能都能正常使用,它至关重要,这里给出的方法也是为了进一步验证前面我们所做的工作.
到找注入id这一步,您至少已经有了这些数据:

* 声卡基础资料:

| 名称 | 解释 |
|---|---|
|Codec: Realtek ALC3246|是告诉了你的声卡型号是ALC3246(ALC256)|
|Address: 0 | 会告诉你生成configdata的数据的前缀是0,比如上面显示输出信息最后一行的`Modified Verbs in One Line:`后面所有的数据中,每组数据的第一位就是这个 `0` ,如果`Address: 2`,那么每组数据的第一位就是 `2` ,这个后面我们会用到它 |
|DevID: 283902550 (0x10ec0256) | 283902550是0x10ec0256的10进制值,0x10ec 是指vendorID(芯片供应商ID),是REALTEK的设备标识,0256是指型号,去掉前面的0,您的声卡型号就是:ALC256|

* 整理出来的有效节点及路径

|有效节点|10进制|设备名称|路径|
|---|---|---|---|
| 0x14 | 20 | Speaker out|**20->2**
| 0x21 | 33 | HP out |**33->3**|
| 0x19 | 25 | Headset Mic in|**8->35->25** **9->34->25**|
| 0x1a | 26 | Headphone Mic in|**8->35->26** **9->34->26**|
| 0x12 | 18 | Internal Mic in|**8->35->18**|

* 最终的`ConfigData`数据:

`
01271c70 01271d01 01271ea6 01271f90 01371cf0 01371d00 01371e00 01371f40 01471c40 01471d01 01471e17 01471f90 01470c02 01871cf0 01871d00 01871e00 01871f40 01971c70 01971d10 01971eab 01971f02 01a71cf0 01a71d00 01a71e00 01a71f40 01b71cf0 01b71d00 01b71e00 01b71f40 01d71cf0 01d71d00 01d71e00 01d71f40 01e71cf0 01e71d00 01e71e00 01e71f40 02171c30 02171d10 02171e2b 02171f02 02170c02
`
下一步,我们就要将这些数据`放`进`AppleALC`相应的位置,让它发挥作用.
操作步骤:

1. 创建`AppleALC`的本地仓库的克隆版本:
    * 使用`git`命令,更多`git`命令的用法请参考[git使用简易指南](http://www.bootcss.com/p/git-guide/):
        
        ```sh
        mkdir ~/git # 在家目录下新建立`git`目录
        cd ~/git    # 进入`git`目录
        git clone https://github.com/vit9696/AppleALC   # 克隆AppleALC到本地
        ```
        
    * 或者通过浏览器下载 [AppleALC最新版](https://github.com/vit9696/AppleALC/archive/master.zip) 

2. 打开`AppleALC`目录,进入`Resources`目录,你会发现这里面`躺`着截止到目前所支持的声卡的全部型号.我的声卡是`ALC256`,我就点击`ALC256`,如图显示:
   ![ALC256_Resources](http://ous2s14vo.bkt.clouddn.com/ALC256_Resources.png)
    我们会发现该目录下包括了一个定义文件`Info.plist`,三个`layout`开头的文件以及三个`Platforms`开头的文件.其中`layout13.xml.zlib` `layout28.xml.zlib` `layout56.xml.zlib`


# 编译AppleALC
使用xcode
通过lilu联合编译
# 注入id
# 测试
## 检查`AppleALC`是否正确加载
打开终端,输入命令:

```sh
kextstat | grep AppleALc
```
显示内容如下:

```sh
kextstat | grep AppleALC
   36    0 0xffffff7f8331b000 0xb0000    0xb0000
       as.vit9696.AppleALC (1.2.1) 
       7CDA2635-8BE4-36E1-B882-8CA3B90284F3 <35 7 5 4 3 2 1>
```
我们可以看到`AppleALC`驱动已经被正确加载,版本是`1.2.1`,如果没有内容输出,那么就有可能没有加载.通常这种情况是因为`Lilu`的版本引起的,可以尝试使用`Lilu` Debug版本.


## 检查注入id是否正确
打开终端,输入命令:

```sh
ioreg -l | grep layout-id
```

显示内容如下:

```ruby
~ % ioreg -l | grep layout-id
    | |   | |   "layout-id" = <38000000>
    | |   |             | |   "IOAudioEngineDeviceDescription" = {
    "num-internal-mics"=1,
    "driver digital input gain"=0,
    "layout-id"=56,
    "post-processing input gain"=25,
    "VP-pregain"=25}
```
为了便于讲解,我将内容做了换行处理.
其中的`"layout-id"=56`就是指注入id是 `56` ,而`<38000000>`是`56`的16进制

## 检查`PinConfigurations`
使用`IORegistryExplorer.app`,找到`HDEF@1F,3`,右侧的`PinConfigurations`就是最终的四个节点的数值,同时我们发现其它的节点已经不存在了,这样的结果正是我们需要的.
![ioreg_pinconfigurations](http://ous2s14vo.bkt.clouddn.com/ioreg_pinconfigurations.png)

 
# 其它问题
耳机切换
睡眠唤醒
去除底噪
## 声卡驱动了,音量调节的图标也显示正常,就是不发声怎么办
如果您的声卡使用了AppleALC,也注入了正确的ID后不发声怎么办呢?这个问题就出现在有效节点和路径不正确上面.
所谓条条大路通罗马,我们总不能在同一棵树上吊死吧.现在可以请出[VoodooHDA](https://github.com/daliansky/VoodooHDA-2.9.0-Clover-V10)万能声卡驱动程序了,说它万能是不正确的,如果它万能了估计就没`AppleALC`啥事儿了吧.这里可以借助`VoodooHDA`自带的应用程序:[getdump](https://github.com/daliansky/VoodooHDA-2.9.0-Clover-V10/raw/master/getdump),使用方法:打开终端,输入命令:

```sh
sudo cp ~/Downloads/getdump /usr/local/bin  # 将getdump命令复制到/usr/local/bin目录下
sudo chmod +x /usr/local/bin/getdump    # 为getdump添加执行权限
getdump > ~/Desktop/voodoo_dump.txt
```
用它可以生成一份`voodoo_dump.txt`的文件,里面会有两段以`DUMPING Playback/Record Paths`开头的文字描述,这里面即包括了有效节点,同时也包括了有效的路径
![path1](http://ous2s14vo.bkt.clouddn.com/path1.png)
![path2](http://ous2s14vo.bkt.clouddn.com/path2.png)
从上面的两张截图中,可以将有效的节点和路径整理出下面的表格:

|有效节点|10进制|设备名称|路径|
|---|---|---|---|
| 0x14 | 20 | Speaker out|**20->12->2**
| 0x21 | 33 | HP out |**33->13->3**|
| 0x19 | 25 | Headset Mic in|**8->35->24** **8->35->29备用**|
| 0x12 | 18 | Internal Mic in|**9->34->18** **9->34->29备用**|
有了这个表格,再结合`configdata`,找出有效的ID,编译`AppleALC`,注入ID并使用声卡驱动.

# HDA工具下载及使用
制作声卡仿冒需要用到的工具,我已经同步到仓库,您可以打包下载也可以通过git同步到本地

* 下载链接:[https://github.com/daliansky/dell7000/tree/master/hda-tools](https://github.com/daliansky/dell7000/tree/master/hda-tools)
* 如何安装
    * 将`hda-tools`目录下的所有文件复制到`/usr/local/bin`下,如果`/usr/local/bin`目录不存在,需要新建立,命令如下:
    
    ```sh
sudo mkdir /usr/local/bin   # 建立/usr/local/bin子目录
sudo cp ~/Downloads/hda-tools/* /usr/local/bin  # 将hda-tools目录下所有的应用程序复制到/usr/local/bin目录下
```
* 如何使用
    * 打开终端,输入命令,直接执行.例如:

    ```sh 
    verbit.sh codec#0 > codec_dump.txt    # 有效节点格式化
    codecgraph codec#0    # 自动生成pathmap图,文件位于codec#0相同目录下
    hda-verb 0x19 0x707 0x20    # 耳机睡眠唤醒无声修正
    widget_dump.sh  # 读取SET_PIN_WIDGET_CONTROL数值 
    ```
    
# 关于打赏
您的支持就是我更新的动力！
如果不希望看到博主停更的话，请点击下方的 `打赏` 支持一下，有钱的捧个钱场，没钱的捧个人场，谢谢大家！

# QQ群:
331686786 [一起黑苹果](http://shang.qq.com/wpa/qunwpa?idkey=db511a29e856f37cbb871108ffa77a6e79dde47e491b8f2c8d8fe4d3c310de91)

